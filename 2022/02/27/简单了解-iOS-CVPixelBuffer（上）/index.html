<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->


    

<!-- keywords -->



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="新生代农民工">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="新生代农民工">
    
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="记录成长，总结工作">
    <meta name="description" content="前言：在iOS中，我们会常常看到 CVPixelBufferRef 这个类型，最常见到的场景是在Camera 采集的时候，返回的数据中有一个CMSampleBufferRef，而每个CMSampleBufferRef则包含一个 CVPixelBufferRef，在视频硬解码的返回数据里也是一个 CVPixelBufferRef（里面包含了所有的压缩的图片信息）。在了解了CVPixelBufferR">
<meta property="og:type" content="article">
<meta property="og:title" content="简单了解 iOS CVPixelBuffer (上)">
<meta property="og:url" content="https://caohanchao.github.io/2022/02/27/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3-iOS-CVPixelBuffer%EF%BC%88%E4%B8%8A%EF%BC%89/index.html">
<meta property="og:site_name" content="新生代农民工的博客">
<meta property="og:description" content="前言：在iOS中，我们会常常看到 CVPixelBufferRef 这个类型，最常见到的场景是在Camera 采集的时候，返回的数据中有一个CMSampleBufferRef，而每个CMSampleBufferRef则包含一个 CVPixelBufferRef，在视频硬解码的返回数据里也是一个 CVPixelBufferRef（里面包含了所有的压缩的图片信息）。在了解了CVPixelBufferR">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-27T15:13:48.000Z">
<meta property="article:modified_time" content="2022-02-27T15:26:37.407Z">
<meta property="article:author" content="新生代农民工">
<meta property="article:tag" content="Objective-C,swift">
<meta name="twitter:card" content="summary">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/favicon.ico">
    
    <title>简单了解 iOS CVPixelBuffer (上) · 新生代农民工的主页</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/css/style.css?v=20211217" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/css/dark.css?v=20211217" as="style">
    <link rel="stylesheet" href="/css/dark.css">
    <link rel="stylesheet" href="/css/mobile.css?v=20211217" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js?v=20211217" as="script">
    <link rel="preload" href="/scripts/dark.js?v=20211217" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 6.0.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu">
        
            
                <div style="padding-left: 1px;">&#xe775;</div>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/>新生代农民工的主页</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/">新生代农民工的主页</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">简单了解 iOS CVPixelBuffer (上)</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden">
        
        
            <div>&#xe639;</div>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                简单了解 iOS CVPixelBuffer (上)
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">1.7k</span>阅读时长: <span class="post-count reading-time">8 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2022/02/27</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>在iOS中，我们会常常看到 <code>CVPixelBufferRef</code> 这个类型，最常见到的场景是在Camera 采集的时候，返回的数据中有一个<code>CMSampleBufferRef</code>，而每个<code>CMSampleBufferRef</code>则包含一个 <code>CVPixelBufferRef</code>，在视频硬解码的返回数据里也是一个 <code>CVPixelBufferRef</code>（里面包含了所有的压缩的图片信息）。在了解了<code>CVPixelBufferRef</code>之后，我们将能够掌握并且运用<code>CVPixelBufferRef</code>的使用；</p>
<p>本篇我们主要熟悉下<code>CVPixelBuffer</code>的使用；</p>
<h1 id="CVPixelBuffer-简介"><a href="#CVPixelBuffer-简介" class="headerlink" title="CVPixelBuffer 简介"></a>CVPixelBuffer 简介</h1><p><code>CVPixelBuffer</code>：核心视频像素缓冲区是在主存储器中保存像素的图像缓冲区。生成帧、压缩或解压缩视频或使用 <code>Core Image</code> 的应用程序都可以使用 <code>CVPixelBuffer</code>。</p>
<p><code>CVPixelBufferRef</code>：是像素缓冲区类型，对<code>CVPixelBuffer</code>对象的引用。像素缓冲区类型基于图像缓冲区类型；像素缓冲器实现了图像缓冲器的存储器存储。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">    @typedef	CVPixelBufferRef</span><br><span class="line">    @abstract   Based on the image buffer type. The pixel buffer implements the memory storage for an image buffer.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">typedef CVImageBufferRef CVPixelBufferRef;</span><br></pre></td></tr></table></figure>
<p>由于CVPixelBufferRef是C中的对象，所以没有ARC内存管理，必须由开发者自己去管理引用计数，控制对象生命周期；</p>
<p>首先，我们先来了解有关<code>CVPixelBufferRef</code>的基础方法，例如：<code>CVPixelBufferRef</code>的创建、持有、释放；</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>创建的方法有四种，前三种常用到：</p>
<ul>
<li>CVPixelBufferCreate()</li>
<li>CVPixelBufferCreateWithBytes()</li>
<li>CVPixelBufferCreateWithPlanarBytes()</li>
<li>CVPixelBufferCreateWithIOSurface()</li>
</ul>
<h3 id="普通的创建方法"><a href="#普通的创建方法" class="headerlink" title="普通的创建方法"></a>普通的创建方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">    为给定大小和像素格式创建单个像素缓冲区</span><br><span class="line">    @function   CVPixelBufferCreate</span><br><span class="line">    @abstract   Call to create a single PixelBuffer for a given size and pixelFormatType.</span><br><span class="line">    @discussion Creates a single PixelBuffer for a given size and pixelFormatType. It allocates the necessary memory based on the pixel dimensions, pixelFormatType and extended pixels described in the pixelBufferAttributes. Not all parameters of the pixelBufferAttributes will be used here.</span><br><span class="line">    @param      width   Width of the PixelBuffer in pixels.</span><br><span class="line">    @param      height  Height of the PixelBuffer in pixels.</span><br><span class="line">    @param	pixelFormatType		Pixel format indentified by its respective OSType.</span><br><span class="line">    @param	pixelBufferAttributes      A dictionary with additional attributes for a pixel buffer. This parameter is optional. See BufferAttributeKeys for more details.</span><br><span class="line">    @param      pixelBufferOut          The new pixel buffer will be returned here</span><br><span class="line">    @result	returns kCVReturnSuccess on success.</span><br><span class="line">*/    </span><br><span class="line">CV_EXPORT CVReturn CVPixelBufferCreate(</span><br><span class="line">    CFAllocatorRef CV_NULLABLE allocator,</span><br><span class="line">    size_t width,</span><br><span class="line">    size_t height,</span><br><span class="line">    OSType pixelFormatType,</span><br><span class="line">    CFDictionaryRef CV_NULLABLE pixelBufferAttributes,</span><br><span class="line">    CV_RETURNS_RETAINED_PARAMETER CVPixelBufferRef CV_NULLABLE * CV_NONNULL pixelBufferOut) __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_4_0);</span><br></pre></td></tr></table></figure>

<h3 id="创建一个由内存位置指定数据的像素缓冲区"><a href="#创建一个由内存位置指定数据的像素缓冲区" class="headerlink" title="创建一个由内存位置指定数据的像素缓冲区"></a>创建一个由内存位置指定数据的像素缓冲区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">    为给定大小和像素格式创建一个像素缓冲区，其中包含由内存位置指定的数据</span><br><span class="line">    @function CVPixelBufferCreateWithBytes</span><br><span class="line">    @abstract Call to create a single PixelBuffer for a given size and pixelFormatType based on a passed in piece of memory.</span><br><span class="line">    @discussion Creates a single PixelBuffer for a given size and pixelFormatType. Not all parameters of the pixelBufferAttributes will be used here. It requires a release callback function that will be called, when the PixelBuffer gets destroyed so that the owner of the pixels can free the memory.</span><br><span class="line">    @param width   Width of the PixelBuffer in pixels</span><br><span class="line">    @param height  Height of the PixelBuffer in pixels</span><br><span class="line">    @param pixelFormatType Pixel format indentified by its respective OSType.</span><br><span class="line">    @param baseAddress Address of the memory storing the pixels.</span><br><span class="line">    @param bytesPerRow Row bytes of the pixel storage memory.</span><br><span class="line">    @param releaseCallback         CVPixelBufferReleaseBytePointerCallback function that gets called when the PixelBuffer gets destroyed.</span><br><span class="line">    @param releaseRefCon           User data identifying the PixelBuffer for the release callback.</span><br><span class="line">    @param pixelBufferAttributes      A dictionary with additional attributes for a a pixel buffer. This parameter is optional. See PixelBufferAttributes for more details.</span><br><span class="line">    @param pixelBufferOut          The new pixel buffer will be returned here</span><br><span class="line">    @result returns kCVReturnSuccess on success.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">CV_EXPORT CVReturn CVPixelBufferCreateWithBytes(</span><br><span class="line">    CFAllocatorRef CV_NULLABLE allocator,</span><br><span class="line">    size_t width,</span><br><span class="line">    size_t height,</span><br><span class="line">    OSType pixelFormatType,</span><br><span class="line">    void * CV_NONNULL baseAddress,</span><br><span class="line">    size_t bytesPerRow,</span><br><span class="line">    CVPixelBufferReleaseBytesCallback CV_NULLABLE releaseCallback,</span><br><span class="line">    void * CV_NULLABLE releaseRefCon,</span><br><span class="line">    CFDictionaryRef CV_NULLABLE pixelBufferAttributes,</span><br><span class="line">    CV_RETURNS_RETAINED_PARAMETER CVPixelBufferRef CV_NULLABLE * CV_NONNULL pixelBufferOut) __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_4_0);</span><br></pre></td></tr></table></figure>


<h3 id="创建一个平面格式的CVPixelBuffer"><a href="#创建一个平面格式的CVPixelBuffer" class="headerlink" title="创建一个平面格式的CVPixelBuffer"></a>创建一个平面格式的CVPixelBuffer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">    @function   CVPixelBufferCreateWithPlanarBytes</span><br><span class="line">    @abstract   Call to create a single PixelBuffer in planar format for a given size and pixelFormatType based on a passed in piece of memory.</span><br><span class="line">    @discussion Creates a single PixelBuffer for a given size and pixelFormatType. Not all parameters of the pixelBufferAttributes will be used here. It requires a release callback function that will be called, when the PixelBuffer gets destroyed so that the owner of the pixels can free the memory.</span><br><span class="line">    @param      width			Width of the PixelBuffer in pixels</span><br><span class="line">    @param      height			Height of the PixelBuffer in pixels</span><br><span class="line">    @param      pixelFormatType		Pixel format indentified by its respective OSType.</span><br><span class="line">    @param	dataPtr			Pass a pointer to a plane descriptor block, or NULL.</span><br><span class="line">    @param	dataSize		pass size if planes are contiguous, NULL if not.</span><br><span class="line">    @param	numberOfPlanes		Number of planes.</span><br><span class="line">    @param	planeBaseAddress	Array of base addresses for the planes.</span><br><span class="line">    @param	planeWidth		Array of plane widths.</span><br><span class="line">    @param	planeHeight		Array of plane heights.</span><br><span class="line">    @param	planeBytesPerRow	Array of plane bytesPerRow values.</span><br><span class="line">    @param	releaseCallback		CVPixelBufferReleaseBytePointerCallback function that gets called when the PixelBuffer gets destroyed.</span><br><span class="line">    @param	releaseRefCon		User data identifying the PixelBuffer for the release callback.</span><br><span class="line">    @param	pixelBufferAttributes      A dictionary with additional attributes for a a pixel buffer. This parameter is optional. See PixelBufferAttributes for more details.</span><br><span class="line">    @param      pixelBufferOut          The new pixel buffer will be returned here</span><br><span class="line">    @result	returns kCVReturnSuccess on success.</span><br><span class="line">*/</span><br><span class="line">CV_EXPORT CVReturn CVPixelBufferCreateWithPlanarBytes(</span><br><span class="line">    CFAllocatorRef CV_NULLABLE allocator,</span><br><span class="line">    size_t width,</span><br><span class="line">    size_t height,</span><br><span class="line">    OSType pixelFormatType,</span><br><span class="line">    void * CV_NULLABLE dataPtr, // pass a pointer to a plane descriptor block, or NULL</span><br><span class="line">    size_t dataSize, // pass size if planes are contiguous, NULL if not</span><br><span class="line">    size_t numberOfPlanes,</span><br><span class="line">    void * CV_NULLABLE planeBaseAddress[CV_NONNULL ],</span><br><span class="line">    size_t planeWidth[CV_NONNULL ],</span><br><span class="line">    size_t planeHeight[CV_NONNULL ],</span><br><span class="line">    size_t planeBytesPerRow[CV_NONNULL ],</span><br><span class="line">    CVPixelBufferReleasePlanarBytesCallback CV_NULLABLE releaseCallback,</span><br><span class="line">    void * CV_NULLABLE releaseRefCon,</span><br><span class="line">    CFDictionaryRef CV_NULLABLE pixelBufferAttributes,</span><br><span class="line">    CV_RETURNS_RETAINED_PARAMETER CVPixelBufferRef CV_NULLABLE * CV_NONNULL pixelBufferOut) __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_4_0);</span><br></pre></td></tr></table></figure>

<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>在使用 CPU 访问像素数据之前必须调用<code>CVPixelBufferLockBaseAddress</code>,然后再调用<code>CVPixelBufferUnlockBaseAddress</code>。<br>而使用 GPU 访问像素数据时，就没有这个必要了。</p>
<h3 id="填充扩展的PixelBuffer"><a href="#填充扩展的PixelBuffer" class="headerlink" title="填充扩展的PixelBuffer"></a>填充扩展的PixelBuffer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">    填充扩展的PixelBuffer</span><br><span class="line">    @function CVPixelBufferFillExtendedPixels</span><br><span class="line">    @abstract Fills the extended pixels of the PixelBuffer.   This function replicates edge pixels to fill the entire extended region of the image.</span><br><span class="line">    @param pixelBuffer Target PixelBuffer.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">CV_EXPORT CVReturn CVPixelBufferFillExtendedPixels( CVPixelBufferRef CV_NONNULL pixelBuffer ) __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_4_0);</span><br></pre></td></tr></table></figure>

<h3 id="锁定PixelBuffer地址"><a href="#锁定PixelBuffer地址" class="headerlink" title="锁定PixelBuffer地址"></a>锁定PixelBuffer地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">    锁定PixelBuffer地址</span><br><span class="line">    @function CVPixelBufferLockBaseAddress</span><br><span class="line">    @abstract Description Locks the BaseAddress of the PixelBuffer to ensure that the memory is accessible.</span><br><span class="line">    @discussion This API ensures that the CVPixelBuffer is accessible in system memory. This should only be called if the base address is going to be used and the pixel data will be accessed by the CPU.</span><br><span class="line">    @param pixelBuffer Target PixelBuffer.</span><br><span class="line">    @param lockFlags See CVPixelBufferLockFlags.</span><br><span class="line">    @result kCVReturnSuccess if the lock succeeded, or error code on failure</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">CV_EXPORT CVReturn CVPixelBufferLockBaseAddress( CVPixelBufferRef CV_NONNULL pixelBuffer, CVPixelBufferLockFlags lockFlags ) __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_4_0);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解锁PixelBuffer地址"><a href="#解锁PixelBuffer地址" class="headerlink" title="解锁PixelBuffer地址"></a>解锁PixelBuffer地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"></span><br><span class="line">    @function CVPixelBufferUnlockBaseAddress</span><br><span class="line">    @abstract Description Unlocks the BaseAddress of the PixelBuffer.</span><br><span class="line">    @param pixelBuffer Target PixelBuffer.</span><br><span class="line">    @param unlockFlags See CVPixelBufferLockFlags.</span><br><span class="line">    @result kCVReturnSuccess if the unlock succeeded, or error code on failure</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">CV_EXPORT CVReturn CVPixelBufferUnlockBaseAddress( CVPixelBufferRef CV_NONNULL pixelBuffer, CVPixelBufferLockFlags unlockFlags ) __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_4_0);</span><br></pre></td></tr></table></figure>

<h2 id="内存管理（保留或者释放）"><a href="#内存管理（保留或者释放）" class="headerlink" title="内存管理（保留或者释放）"></a>内存管理（保留或者释放）</h2><p>这里在开篇的时候也提到过，由于CVPixelBufferRef是C中的对象，所以不存在ARC内存管理，由开发者自己去管理引用计数，从而控制对象的生命周期；</p>
<h3 id="持有"><a href="#持有" class="headerlink" title="持有"></a>持有</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">    引用计数+1</span><br><span class="line">    @function   CVPixelBufferRetain</span><br><span class="line">    @abstract   Retains a CVPixelBuffer object</span><br><span class="line">    @discussion Equivalent to CFRetain, but NULL safe</span><br><span class="line">    @param      buffer A CVPixelBuffer object that you want to retain.</span><br><span class="line">    @result     A CVPixelBuffer object that is the same as the passed in buffer.</span><br><span class="line">*/</span><br><span class="line">CV_EXPORT CVPixelBufferRef CV_NULLABLE CVPixelBufferRetain( CVPixelBufferRef CV_NULLABLE texture ) __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_4_0);</span><br></pre></td></tr></table></figure>


<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">    引用计数-1</span><br><span class="line">    @function   CVPixelBufferRelease</span><br><span class="line">    @abstract   Releases a CVPixelBuffer object</span><br><span class="line">    @discussion Equivalent to CFRelease, but NULL safe</span><br><span class="line">    @param      buffer A CVPixelBuffer object that you want to release.</span><br><span class="line">*/</span><br><span class="line">CV_EXPORT void CVPixelBufferRelease( CV_RELEASES_ARGUMENT CVPixelBufferRef CV_NULLABLE texture ) __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_4_0);</span><br></pre></td></tr></table></figure>

<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/corevideo/1456666-cvpixelbuffergetheight?language=objc"><code>CVPixelBufferGetHeight</code></a> 返回像素缓冲区的高度<br><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/corevideo/1457241-cvpixelbuffergetwidth?language=objc"><code>CVPixelBufferGetWidth</code></a> 返回像素缓冲区的宽度</p>
<p>这里方法较多，就不一一举例，可以查看<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/corevideo/cvpixelbuffer?language=objc"><code>官方文档</code></a></p>
<h1 id="像素格式类型-kCVPixelFormatType"><a href="#像素格式类型-kCVPixelFormatType" class="headerlink" title="像素格式类型 kCVPixelFormatType"></a>像素格式类型 kCVPixelFormatType</h1><p><strong>RGB :</strong></p>
<p><code>kCVPixelFormatType_32BGRA = &#39;BGRA&#39;</code><br><code>kCVPixelFormatType_32BGRA = &#39;BGRA&#39;</code>,<br><code>kCVPixelFormatType_32ABGR = &#39;ABGR&#39;</code>,  <br><code>kCVPixelFormatType_32RGBA = &#39;RGBA&#39;</code>,</p>
<p><strong>NV12 :</strong></p>
<p><code>kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange = &#39;420v&#39;</code>,<br><code>kCVPixelFormatType_420YpCbCr8BiPlanarFullRange = &#39;420f&#39;</code>,</p>
<p><strong>YUV420P :</strong><br><code>kCVPixelFormatType_420YpCbCr8Planar = &#39;y420&#39;</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kCVPixelFormatType_&#123;长度|序列&#125;&#123;颜色空间&#125;&#123;Planar|BiPlanar&#125;&#123;VideoRange|FullRange&#125;</span><br></pre></td></tr></table></figure>

<p>从这里类型可以看出，YUV格式和RGB格式都是可以创建成CVPixelBuffer；</p>
<p>那么拿到CVPixelBufferRef后，如果要显示的话， 我们可以通过CVPixelBufferRef转成UIImage，或者通过绘制纹理的形式展示。</p>
<blockquote>
<p>想要更清楚的了解kCVPixelFormatType这些类型，那么就需要我们对YUV格式和RGB格式有更深入的了解，所以在下一篇中，我们将对两种格式进行详细的说明，然后再来看kCVPixelFormatType，那样将会加深我们对此的了解程度。</p>
</blockquote>
<p><a href="https://caohanchao.github.io/2022/02/27/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3-iOS-CVPixelBuffer%EF%BC%88%E4%B8%AD%EF%BC%89">下一章：「简单了解 iOS CVPixelBuffer （中）」</a></p>

    </article>
    <!-- license -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://caohanchao.github.io">新生代农民工</a>
            <p>原文链接：<a href="https://caohanchao.github.io/2022/02/27/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3-iOS-CVPixelBuffer%EF%BC%88%E4%B8%8A%EF%BC%89/">https://caohanchao.github.io/2022/02/27/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3-iOS-CVPixelBuffer%EF%BC%88%E4%B8%8A%EF%BC%89/</a>
            <p>发表日期：<a href="https://caohanchao.github.io/2022/02/27/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3-iOS-CVPixelBuffer%EF%BC%88%E4%B8%8A%EF%BC%89/">February 27th 2022, 11:13:48 pm</a>
            <p>更新日期：<a href="https://caohanchao.github.io/2022/02/27/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3-iOS-CVPixelBuffer%EF%BC%88%E4%B8%8A%EF%BC%89/">February 27th 2022, 11:26:37 pm</a>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2022/02/27/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3-iOS-CVPixelBuffer%EF%BC%88%E4%B8%AD%EF%BC%89/" title="简单了解 iOS CVPixelBuffer（中）">
                    <div class="nextTitle">简单了解 iOS CVPixelBuffer（中）</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2022/02/27/CocoaPods%E4%B8%ADpodsepc%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%AF%A6%E6%83%85/" title="CocoaPods中podsepc文件设置详情">
                    <div class="prevTitle">CocoaPods中podsepc文件设置详情</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            

            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:627203960@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="https://github.com/caohanchao" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="https://juejin.cn/user/273091408183054/posts" class="iconfont-archer juejin" target="_blank" title=juejin></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
             
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
            
        </div>
    	
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">前言：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CVPixelBuffer-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">CVPixelBuffer 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">2.1.</span> <span class="toc-text">创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">普通的创建方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%94%B1%E5%86%85%E5%AD%98%E4%BD%8D%E7%BD%AE%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E5%83%8F%E7%B4%A0%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.1.2.</span> <span class="toc-text">创建一个由内存位置指定数据的像素缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B9%B3%E9%9D%A2%E6%A0%BC%E5%BC%8F%E7%9A%84CVPixelBuffer"><span class="toc-number">2.1.3.</span> <span class="toc-text">创建一个平面格式的CVPixelBuffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-number">2.2.</span> <span class="toc-text">修改</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%89%A9%E5%B1%95%E7%9A%84PixelBuffer"><span class="toc-number">2.2.1.</span> <span class="toc-text">填充扩展的PixelBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%AE%9APixelBuffer%E5%9C%B0%E5%9D%80"><span class="toc-number">2.2.2.</span> <span class="toc-text">锁定PixelBuffer地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%94%81PixelBuffer%E5%9C%B0%E5%9D%80"><span class="toc-number">2.2.3.</span> <span class="toc-text">解锁PixelBuffer地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BF%9D%E7%95%99%E6%88%96%E8%80%85%E9%87%8A%E6%94%BE%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">内存管理（保留或者释放）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E6%9C%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">持有</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE"><span class="toc-number">2.3.2.</span> <span class="toc-text">释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5"><span class="toc-number">2.4.</span> <span class="toc-text">检查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F%E7%B1%BB%E5%9E%8B-kCVPixelFormatType"><span class="toc-number">3.</span> <span class="toc-text">像素格式类型 kCVPixelFormatType</span></a></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 11
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/27</span>
            <a class="archive-post-title" href="/2022/02/27/CocoaPods%E4%B8%ADpodsepc%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%AF%A6%E6%83%85/">CocoaPods中podsepc文件设置详情</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> Invalid date </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span>
            <a class="archive-post-title" href="/2022/02/18/hello-world/">Hello World</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/27</span>
            <a class="archive-post-title" href="/2022/02/27/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3-iOS-CVPixelBuffer%EF%BC%88%E4%B8%8A%EF%BC%89/">简单了解 iOS CVPixelBuffer (上)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/27</span>
            <a class="archive-post-title" href="/2022/02/27/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3-iOS-CVPixelBuffer%EF%BC%88%E4%B8%AD%EF%BC%89/">简单了解 iOS CVPixelBuffer（中）</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/26</span>
            <a class="archive-post-title" href="/2022/02/26/%E4%BA%86%E8%A7%A3-Mach-O%E6%96%87%E4%BB%B6/">了解 Mach-O文件</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/26</span>
            <a class="archive-post-title" href="/2022/02/26/%E9%93%BE%E6%8E%A5%E5%99%A8%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F/">链接器到底干了些什么？</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/20</span>
            <a class="archive-post-title" href="/2022/02/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-iOS-RunLoop/">深入理解 iOS RunLoop</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/19</span>
            <a class="archive-post-title" href="/2022/02/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-iOS-Runtime/">深入理解 iOS Runtime</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/19</span>
            <a class="archive-post-title" href="/2022/02/19/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CocoaPods%E5%88%B6%E4%BD%9C%E7%A7%81%E6%9C%89%E5%BA%93/">如何使用CocoaPods制作私有库</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/19</span>
            <a class="archive-post-title" href="/2022/02/19/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88/">iOS 组件化方案</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span>
            <a class="archive-post-title" href="/2022/02/18/iOS-AVAudioSession/">iOS 音频入门之AVAudioSession</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
            <span class="sidebar-tag-name" data-tags="音视频">
                <span class="iconfont-archer">&#xe606;</span>
                音视频
            </span>
        
            <span class="sidebar-tag-name" data-tags="架构">
                <span class="iconfont-archer">&#xe606;</span>
                架构
            </span>
        
            <span class="sidebar-tag-name" data-tags="原理篇">
                <span class="iconfont-archer">&#xe606;</span>
                原理篇
            </span>
        
            <span class="sidebar-tag-name" data-tags="CocoaPods">
                <span class="iconfont-archer">&#xe606;</span>
                CocoaPods
            </span>
        
            <span class="sidebar-tag-name" data-tags="Objective-C">
                <span class="iconfont-archer">&#xe606;</span>
                Objective-C
            </span>
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMetaRoot = "/"
    if (siteMetaRoot === "undefined") {
        siteMetaRoot = '/'
    }
    var siteMeta = {
        url: "https://caohanchao.github.io",
        root: siteMetaRoot,
        author: "新生代农民工"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/scripts/main.js?v=20211217"></script>
        <!-- dark mode -->
        <script src="/scripts/dark.js?v=20211217"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/scripts/share.js?v=20211217" async></script>
        
        <!-- mermaid -->
        
    </body>
</html>
